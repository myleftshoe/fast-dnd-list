{"version":3,"sources":["events.js","Draggable.js","ElementCache.js","utils/math.clamp.js","Handler.js","Sortable.js","App.js","index.js","array.js"],"names":["preventDefault","e","transitions","grasp","moveIntoPlace","settleIntoPlace","Draggable","element","props","startPosition","currentPosition","direction","left","offsetLeft","top","offsetTop","height","offsetHeight","width","offsetWidth","_window$getComputedSt","window","getComputedStyle","marginTop","marginBottom","marginLeft","marginRight","margins","parseInt","bottom","right","initialCenter","dimensions","Math","max","displacement","center","n","min","this","absoluteCenter","parentNode","clientHeight","scrollTop","position","_this$displacement","Object","slicedToArray","x","y","style","transform","concat","willChange","zIndex","transition","classList","add","dragClassName","raised","_this","Promise","resolve","_element$getBoundingC","getBoundingClientRect","keyframes","animate","duration","easing","onfinish","target","eventName","event","reject","addEventListener","handler","_ref","removeEventListener","requestAnimationFrame","remove","release","_release","asyncToGenerator","regenerator_default","a","mark","_callee","wrap","_context","prev","next","stop","_x","_x2","apply","arguments","elementCache","elements","map","Element","get","index","find","indexOf","findIndex","_ref2","count","length","removeAt","splice","resetStyles","forEach","_ref3","print","console","table","item","innerText","translateY","_element$translateY","math_clamp","Handler","container","draggable","draggableIndex","placeholderIndex","rafId","isHolding","scrollable","ElementCache","Array","from","children","maxScrollableHeight","scrollHeight","lastCenterY","setTimeout","undefined","overflowY","move","shift","_ref$translateY","prevent","repeatUntilNextTouchMove","ts","_draggable","_draggable$absoluteCe","centerY","_getScrollValue","bottomOffset","draggableY","clamp","offset","triggerOffset","getScrollValue","_getScrollValue2","trunc","cancelAnimationFrame","targetY","_elementCache$get","windowScrollY","pageYOffset","document","documentElement","body","scrollableVisibleTop","indexes","toIndex","clearTimeout","Sortable","_useState","useState","_useState2","setHandler","_useState3","_useState4","started","setStarted","_useState5","_useState6","usingTouch","setUsingTouch","containerRef","useRef","start","current","onGrasp","touches","clientX","clientY","Drag","onDrag","end","result","onDrop","useEffect","events","onTouchStart","onTouchEnd","onMouseDown","onMouseUp","react_default","createElement","assign","onPointerDown","pointerType","onContextMenu","className","ref","defaultProps","generateItems","toConsumableArray","keys","k","ReactDOM","render","items","setItems","array","removedElements","filter","_","includes","remainingElements","push","multiMove","key","getElementById"],"mappings":"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","file":"static/js/main.a1c74b6a.chunk.js","sourcesContent":["export function preventDefault(e) { e.preventDefault() }\r\nexport function stopPropagation(e) { e.stopPropagation() }\r\n\r\nexport function fireAndForget(target, eventName) {\r\n    return new Promise((resolve, reject) => {\r\n        const handler = ({ target }) => {\r\n            target.removeEventListener(eventName, handler, false);\r\n            resolve();\r\n        }\r\n        target.addEventListener(eventName, handler, false);\r\n    })\r\n}\r\n","import './Draggable.css';\r\nimport { fireAndForget } from './events';\r\nimport 'web-animations-js/web-animations.min';\r\n\r\nconst transitions = {\r\n    grasp: 'box-shadow .2s ease-in-out, background-color .2s ease-in-out',\r\n    moveIntoPlace: 'transform .2s ease-in-out',\r\n    settleIntoPlace: 'box-shadow .2s ease-in-out, background-color .2s ease-in-out'\r\n}\r\n\r\nexport default function Draggable(element, props) {\r\n\r\n    let startPosition = null;\r\n    let currentPosition = null;\r\n    let direction = null;\r\n\r\n    const { offsetLeft: left, offsetTop: top, offsetHeight: height, offsetWidth: width } = element;\r\n    const { marginTop, marginBottom, marginLeft, marginRight } = window.getComputedStyle(element);\r\n\r\n    const margins = {\r\n        top: parseInt(marginTop),\r\n        bottom: parseInt(marginBottom),\r\n        left: parseInt(marginLeft),\r\n        right: parseInt(marginRight),\r\n    };\r\n\r\n    const initialCenter = [left + width / 2 + margins.left, top + height / 2 + margins.top];\r\n    const dimensions = {\r\n        width: width + Math.max(margins.left, margins.right),\r\n        height: height + Math.max(margins.top, margins.bottom),\r\n    }\r\n\r\n    return {\r\n\r\n        get element() { return element },\r\n\r\n        get direction() { return direction },\r\n\r\n        get displacement() {\r\n            if (!currentPosition || !startPosition)\r\n                return null;\r\n            return [\r\n                currentPosition[0] - startPosition[0],\r\n                currentPosition[1] - startPosition[1],\r\n            ]\r\n        },\r\n\r\n        get dimensions() { return dimensions },\r\n\r\n        get center() {\r\n            const clamp = (n, min, max) => Math.max(Math.min(n, max), min);\r\n            return clamp(this.absoluteCenter[1], 0, element.parentNode.clientHeight) - element.parentNode.scrollTop;\r\n        },\r\n\r\n        get absoluteCenter() {\r\n            if (!this.displacement)\r\n                return [initialCenter[0], initialCenter[1]];\r\n            return [initialCenter[0] + this.displacement[0], initialCenter[1] + this.displacement[1]];\r\n        },\r\n\r\n        get margins() { return margins },\r\n\r\n        set position(position) {\r\n            if (currentPosition) {\r\n                if (position[1] < currentPosition[1])\r\n                    direction = 'up';\r\n                else\r\n                    direction = 'down';\r\n            }\r\n            currentPosition = position;\r\n            if (!startPosition)\r\n                startPosition = currentPosition;\r\n            const [x, y] = this.displacement;\r\n            element.style.transform = `translate(${x}px,${y}px)`;\r\n        },\r\n\r\n        get position() { return currentPosition },\r\n\r\n        grasp() {\r\n            element.style.willChange = 'transform';\r\n            element.style.zIndex = 999;\r\n            // element.style.pointerEvents = 'none';\r\n            element.style.position = 'relative';\r\n            element.style.transition = transitions.grasp;\r\n            element.classList.add(props.dragClassName);\r\n            props.raised && element.classList.add('shadow');\r\n        },\r\n\r\n        moveIntoPlace(x, y) {\r\n            return new Promise(resolve => {\r\n                const { left, top } = element.getBoundingClientRect();\r\n                const keyframes = [\r\n                    { transform: `translate(${left - x - this.margins.left}px,${top - y}px)` },\r\n                    { transform: `translate(${0}px,${0}px)` },\r\n                ];\r\n                const animation = element.animate(keyframes, {\r\n                    duration: 200,\r\n                    easing: 'ease-in-out',\r\n                });\r\n                animation.onfinish = () => {\r\n                    // The animation does not preserve its end state ->\r\n                    //  update the styles directly to reflect final state.\r\n                    element.style.transition = null;\r\n                    element.style.transform = `translate(${0}px,${0}px)`;\r\n                    resolve();\r\n                }\r\n            });\r\n            // Not supported in Chrome yet: (polyfill available but above Promise is simpler)\r\n            // return animation.finished;\r\n        },\r\n\r\n        settleIntoPlace() {\r\n            const event = fireAndForget(element, \"transitionend\");\r\n            requestAnimationFrame(() => {\r\n                element.classList.remove(props.dragClassName);\r\n                element.classList.remove('shadow');\r\n                element.style.transition = transitions.settleIntoPlace;\r\n                element.style.zIndex = null;\r\n                element.style.transition = null;\r\n                element.style.transform = null;\r\n            });\r\n            return event;\r\n        },\r\n\r\n        async release(x, y) {\r\n            await this.moveIntoPlace(x, y);\r\n            await this.settleIntoPlace();\r\n        }\r\n    }\r\n}\r\n","export default function elementCache(elements) {\r\n\r\n    const elementCache = elements.map(element => new Element(element));\r\n\r\n    return {\r\n\r\n        get: index => elementCache[index],\r\n\r\n        find: element => elementCache.find(({ element: cachedElement }) => cachedElement === element),\r\n\r\n        indexOf: element => elementCache.findIndex(({ element: cachedElement }) => cachedElement === element),\r\n\r\n        get count() { return elementCache.length },\r\n\r\n        removeAt(index) { elementCache.splice(index, 1) },\r\n\r\n        resetStyles() {\r\n            elementCache.forEach(({ element }) => {\r\n                element.style.transition = null;\r\n                element.style.transform = null;\r\n            });\r\n        },\r\n\r\n        print() {\r\n            console.table(elementCache.map(element => {\r\n                const { element: { innerText: item }, top, translateY } = element;\r\n                return { item, top, translateY }\r\n            }));\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction Element(element) {\r\n    const { offsetTop, offsetHeight: height, translateY = 0 } = element;\r\n    return {\r\n        element,\r\n        offsetTop,\r\n        height,\r\n        translateY,\r\n        get top() { return this.offsetTop + this.translateY }\r\n    }\r\n}","export default (n, min, max) => Math.max(Math.min(n, max), min);\r\n","import Draggable from './Draggable';\r\nimport ElementCache from './ElementCache';\r\nimport clamp from './utils/math.clamp';\r\n\r\nexport default function (container, props) {\r\n\r\n    const scrollable = container.parentNode;\r\n    let draggable;\r\n    let draggableIndex;\r\n    let placeholderIndex;\r\n    const children = Array.from(container.children);\r\n    let elementCache = new ElementCache(children);\r\n    let rafId;\r\n    let isHolding;\r\n    const maxScrollableHeight = scrollable.scrollHeight;\r\n    let lastCenterY = null;\r\n\r\n    const scrollableVisibleTop = function () {\r\n        const windowScrollY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n        return container.offsetTop - windowScrollY - scrollable.scrollTop\r\n    }\r\n\r\n    return {\r\n\r\n        grasp(element) {\r\n\r\n            if (element === container || draggable) return;\r\n\r\n            draggable = new Draggable(element, props);\r\n\r\n            draggableIndex = elementCache.indexOf(draggable.element);\r\n\r\n            placeholderIndex = draggableIndex;\r\n\r\n            // elementCache.removeAt(draggableIndex);\r\n\r\n            isHolding = setTimeout(() => {\r\n                isHolding = undefined;\r\n                disableScrolling();\r\n                draggable.grasp();\r\n            }, 300);\r\n\r\n        },\r\n\r\n        move(x, y) {\r\n\r\n            if (prevent()) return;\r\n\r\n            rafId = requestAnimationFrame(repeatUntilNextTouchMove);\r\n\r\n            // Allows auto scroll to continue when draggable is held in same place\r\n            function repeatUntilNextTouchMove(ts) {\r\n\r\n                const { direction, dimensions: { height }, absoluteCenter: [, centerY] } = draggable;\r\n\r\n\r\n                const [scrollTop, scrollOffset] = getScrollValue();\r\n                scrollable.scrollTop = scrollTop;\r\n\r\n                draggable.position = [x, clamp(y + scrollTop, 0, maxScrollableHeight)];\r\n\r\n                if (Math.trunc(centerY) === Math.trunc(lastCenterY)) return;\r\n                lastCenterY = centerY;\r\n\r\n\r\n                if (direction === 'down') {\r\n                    for (placeholderIndex; placeholderIndex < elementCache.count; placeholderIndex++) {\r\n                        const element = elementCache.get(placeholderIndex);\r\n                        if (element.element === draggable.element) continue;\r\n                        if (element.top > centerY) break;\r\n                        element.translateY -= height;\r\n                        shift(element);\r\n                    }\r\n                }\r\n                else if (direction === 'up') {\r\n                    for (placeholderIndex; placeholderIndex > 0; placeholderIndex--) {\r\n                        const element = elementCache.get(placeholderIndex - 1);\r\n                        if (element.element === draggable.element) continue;\r\n                        const bottom = element.top + element.height;\r\n                        if (bottom < centerY) break;\r\n                        element.translateY += height;\r\n                        shift(element);\r\n                    }\r\n                }\r\n\r\n                if (placeholderIndex <= 0 || placeholderIndex >= elementCache.count)\r\n                    cancelAnimationFrame(rafId);\r\n                else\r\n                    rafId = requestAnimationFrame(repeatUntilNextTouchMove);\r\n\r\n            }\r\n\r\n            function shift({ element, translateY = 0 }) {\r\n                // element.style.willChange = 'transform';\r\n                // requestAnimationFrame(() => {\r\n                element.style['transition'] = 'transform .2s ease-in-out';\r\n                element.style['transform'] = `translate(${translateY}px)`;\r\n                //     element.style.willChange = null;\r\n                // });\r\n            }\r\n\r\n        },\r\n\r\n        release(e) {\r\n\r\n            if (prevent()) return null;\r\n\r\n            enableScrolling();\r\n\r\n            let targetY;\r\n            if (placeholderIndex < elementCache.count) {\r\n                targetY = elementCache.get(placeholderIndex).top;\r\n            }\r\n            else {\r\n                const { offsetTop, height } = elementCache.get(placeholderIndex - 1);\r\n                targetY = offsetTop + draggable.margins.top + height;\r\n            }\r\n\r\n            targetY = targetY - draggable.dimensions.height + scrollableVisibleTop();\r\n\r\n\r\n            try { return { indexes: [draggableIndex], toIndex: placeholderIndex } }\r\n\r\n            // Do the drop animation after reordering\r\n            finally {\r\n\r\n                draggable.release(0, targetY);\r\n\r\n                elementCache.resetStyles();\r\n                draggable = undefined;\r\n\r\n            }\r\n        },\r\n    }\r\n\r\n    function disableScrolling() {\r\n        scrollable.style.overflowY = 'hidden';\r\n        // scrollable.style.touchAction = 'none';\r\n        // scrollable.addEventListener('touchmove', preventDefault);\r\n    }\r\n\r\n    function enableScrolling() {\r\n        scrollable.style.overflowY = 'scroll';\r\n        // scrollable.style.touchAction = 'pan-y';\r\n        // scrollable.removeEventListener('touchmove', preventDefault);\r\n    }\r\n\r\n    function prevent() {\r\n\r\n        if (isHolding) {\r\n            clearTimeout(isHolding);\r\n            isHolding = undefined;\r\n            draggable = undefined;\r\n        }\r\n\r\n        if (!draggable) return true;\r\n\r\n        cancelAnimationFrame(rafId);\r\n\r\n        return false;\r\n    }\r\n\r\n    function getScrollValue() {\r\n\r\n        const triggerOffset = 80;\r\n        const speedMultiplier = 0.25;\r\n\r\n        const { scrollTop, clientHeight } = scrollable;\r\n\r\n        const bottomOffset = clientHeight - triggerOffset;\r\n        const topOffset = triggerOffset;\r\n        // const maxScrollTop = scrollHeight - Math.min(clientHeight, window.innerHeight);\r\n\r\n        const draggableY = clamp(draggable.absoluteCenter[1] - scrollTop, 0, clientHeight);\r\n        // console.log(draggableY, clientHeight);\r\n\r\n        let offset = 0;\r\n        if (draggableY > bottomOffset)\r\n            offset = draggableY - bottomOffset;\r\n        else if (draggableY < topOffset && scrollTop > 0)\r\n            offset = draggableY - topOffset;\r\n\r\n        const top = scrollTop + offset * speedMultiplier;\r\n        // console.log(top, offset, scrollTop);\r\n        return [top, offset];\r\n    }\r\n\r\n}\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Handler from './Handler';\r\nimport { preventDefault } from './events';\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport default function Sortable(props) {\r\n\r\n    let [handler, setHandler] = useState();\r\n    let [started, setStarted] = useState(false);\r\n    let [usingTouch, setUsingTouch] = useState(true);\r\n\r\n    const containerRef = useRef();\r\n\r\n    useEffect(() => {\r\n        setHandler(new Handler(containerRef.current, props));\r\n    }, [props.children]);\r\n\r\n    useEffect(() => {\r\n        if (!usingTouch && started)\r\n            document.body.addEventListener(\"mousemove\", move);\r\n        return () => {\r\n            document.body.removeEventListener(\"mousemove\", move);\r\n        };\r\n    });\r\n\r\n    useEffect(() => {\r\n        if (usingTouch && started)\r\n            document.body.addEventListener(\"touchmove\", move);\r\n        return () => {\r\n            document.body.removeEventListener(\"touchmove\", move);\r\n        };\r\n    });\r\n\r\n    function handlePointerDown(e) {\r\n        if (e.pointerType === 'touch')\r\n            setUsingTouch(true);\r\n        else\r\n            setUsingTouch(false);\r\n    }\r\n\r\n    function start(e) {\r\n        setStarted(true);\r\n        if (e.target.parentNode !== containerRef.current) return;\r\n        handler.grasp(e.target);\r\n        props.onGrasp && props.onGrasp();\r\n    }\r\n\r\n    function move(e) {\r\n        if (usingTouch)\r\n            handler.move(e.touches[0].clientX, e.touches[0].clientY);\r\n        else\r\n            handler.move(e.clientX, e.clientY);\r\n\r\n        props.Drag && props.onDrag();\r\n    }\r\n\r\n    function end() {\r\n        const result = handler.release();\r\n        setStarted(false);\r\n        result && props.onDrop && props.onDrop(result);\r\n    }\r\n\r\n    let events = {};\r\n\r\n    if (handler) {\r\n        if (usingTouch) events = {\r\n            onTouchStart: start,\r\n            // onTouchMove: move,\r\n            onTouchEnd: end,\r\n        }\r\n        else events = {\r\n            onMouseDown: start,\r\n            // onMouseMove: started ? move : null,\r\n            onMouseUp: end,\r\n            // onMouseLeave:  end,\r\n        }\r\n    }\r\n\r\n    return (\r\n        //\r\n        // Notes:\r\n        //\r\n        // 1. The draggable is positioned relatively. In order for it to not be cut-off when dragged\r\n        // beyond the container edges requires overflow-x: visible on the container. But it's not\r\n        // possible to have overflow visible on one axis and allow the other axis to scroll: the\r\n        // visible axis will be overidden with overflow: auto (google it!).\r\n        // The solution is to wrap the container with overflow-x: visible in a scrollable div as\r\n        // below.\r\n        // Positioning the draggable absolutely allows it to remain visible no matter where it is\r\n        // but will close the placeholder when grasped. It also requires its size to be tweaked\r\n        // on grasp as it loses its container padding.\r\n        //\r\n        // 2. The event listeners are attached to the wrapper (not the container) as the mousemove\r\n        // events do not fire when the draggable is outside the container (and dragged fast so that\r\n        // the mouse leaves the draggable). I.e. the draggable freezes until the mouse is moved over\r\n        // it again. The container fits the list contenet snuggly whereas the wrapper is the full width\r\n        // of the page -> events on the wrapper continue to fire.\r\n        // Update: Now adds mousemove listener to the document so others can go either on container or\r\n        // wrapper. Leave on wrapper for now.\r\n\r\n        <div style={{ overflowY: 'scroll' }}\r\n            onPointerDown={handlePointerDown}\r\n            {...events}\r\n            onContextMenu={preventDefault}\r\n        >\r\n            <div className='container' ref={containerRef}>\r\n                {props.children}\r\n            </div>\r\n        </div >\r\n    )\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nSortable.propTypes = {\r\n    onGrasp: PropTypes.func,\r\n    onDrag: PropTypes.func,\r\n    onDrop: PropTypes.func,\r\n    raised: PropTypes.bool,\r\n    dragClassName: PropTypes.string,\r\n}\r\n\r\nSortable.defaultProps = {\r\n    raised: true,\r\n    dragClassName: 'drag-style',\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport Sortable from './Sortable';\r\nimport { multiMove } from './array';\r\n\r\nconst generateItems = length => [...Array(length).keys()].map(k => `Item ${k}`)\r\n\r\nexport default function App() {\r\n\r\n    let [items, setItems] = useState(generateItems(88));\r\n\r\n    const onDrop = ({ indexes, toIndex }) => setItems(multiMove(items, indexes, toIndex));\r\n\r\n    return <div className='list'>\r\n        <Sortable dragClassName='drag-style' onDrop={onDrop}>\r\n            {items.map(item =>\r\n                <div key={item} className='list-item' style={{ height: item === 'Item 2' ? '70px' : item === 'Item 4' && '100px' }}>{item}</div>)\r\n            }\r\n        </Sortable>\r\n    </div>\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n","export const move = (array, removeFrom = null, insertAt = null) => {\r\n\r\n    // Adds item if removeFrom is null\r\n    // Removes item if insertAt is null\r\n\r\n    if (insertAt === removeFrom) return array;\r\n    if (isNaN(Number(removeFrom) || isNaN(Number(insertAt)))) return array;\r\n\r\n    let _array = [...array];\r\n\r\n    const item = (removeFrom !== null) ? _array.splice(removeFrom, 1)[0] : null;\r\n    if (insertAt !== null) {\r\n        _array.splice(insertAt, 0, item);\r\n    }\r\n\r\n    return _array;\r\n};\r\n\r\nexport const shuffle = array => array\r\n    .map(a => [Math.random(), a])\r\n    .sort((a, b) => a[0] - b[0])\r\n    .map(a => a[1]);\r\n\r\nexport const reverse = array => array.slice().reverse();\r\n\r\nexport function multiMove(array, indexes, toIndex) {\r\n\r\n    const element = array[toIndex];\r\n    const removedElements = array.filter((_, index) => indexes.includes(index));\r\n    const remainingElements = array.filter((_, index) => !indexes.includes(index));\r\n    const index = remainingElements.indexOf(element);\r\n\r\n    if (index > -1)\r\n        remainingElements.splice(index, 0, ...removedElements);\r\n    else\r\n        remainingElements.push(...removedElements);\r\n\r\n    return remainingElements;\r\n\r\n}\r\n\r\n// export function _multiMove(array, indexes, toIndex) {\r\n//     let result = array.slice();\r\n//     indexes.forEach(removeFrom => { result = move(result, removeFrom, toIndex) });\r\n//     return result;\r\n// }"],"sourceRoot":""}